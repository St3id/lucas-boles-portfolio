<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circuit Breaker - Mini-Jeu</title>
    <link href="https://fonts.googleapis.com/css2?family=Work+Sans:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Work Sans', sans-serif;
            background: linear-gradient(135deg, #4e54c8 0%, #8f94fb 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .back-button {
            position: fixed;
            top: 2rem;
            left: 2rem;
            padding: 1rem 2rem;
            background: rgba(255, 255, 255, 0.9);
            color: #4e54c8;
            text-decoration: none;
            font-weight: 600;
            border-radius: 50px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }

        .back-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .game-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 2rem;
            border-radius: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #4e54c8;
            margin-bottom: 1rem;
        }

        .info {
            display: flex;
            justify-content: space-around;
            margin-bottom: 1.5rem;
            font-size: 1.2rem;
            font-weight: 600;
            color: #8f94fb;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(5, 70px);
            grid-template-rows: repeat(5, 70px);
            gap: 8px;
            justify-content: center;
            margin: 2rem auto;
            background: #2d3561;
            padding: 15px;
            border-radius: 15px;
            box-shadow: inset 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .tile {
            background: #1a1f3a;
            border: 2px solid #4e54c8;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tile:hover {
            background: #252b4f;
            transform: scale(1.05);
        }

        .tile.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
        }

        .tile.start {
            background: #2ecc71;
            box-shadow: 0 0 20px rgba(46, 204, 113, 0.8);
        }

        .tile.end {
            background: #e74c3c;
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.8);
        }

        .tile svg {
            width: 50px;
            height: 50px;
            stroke: #fff;
            stroke-width: 4;
            fill: none;
            opacity: 0.9;
        }

        .controls {
            margin-top: 2rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 1rem 2rem;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .new-button {
            background: #8f94fb;
            color: white;
        }

        .new-button:hover {
            background: #6c72d4;
            transform: translateY(-3px);
        }

        .check-button {
            background: #2ecc71;
            color: white;
        }

        .check-button:hover {
            background: #27ae60;
            transform: translateY(-3px);
        }

        .message {
            margin-top: 1rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: #4e54c8;
            min-height: 25px;
        }

        .instructions {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 15px;
            font-size: 0.9rem;
            color: #666;
            line-height: 1.6;
        }

        @media (max-width: 600px) {
            .grid {
                grid-template-columns: repeat(5, 55px);
                grid-template-rows: repeat(5, 55px);
            }
            
            .tile svg {
                width: 40px;
                height: 40px;
            }
        }
    </style>
</head>
<body>
    <a href="games.html" class="back-button">‚Üê Retour aux Jeux</a>
    
    <div class="game-container">
        <h1>‚ö° Circuit Breaker</h1>
        
        <div class="info">
            <div>Niveau: <span id="level">1</span></div>
            <div>Mouvements: <span id="moves">0</span></div>
        </div>

        <div class="grid" id="grid"></div>

        <div class="message" id="message">Connectez le d√©part √† l'arriv√©e !</div>

        <div class="controls">
            <button class="new-button" onclick="generateLevel()">Nouveau Niveau</button>
            <button class="check-button" onclick="checkSolution()">V√©rifier</button>
        </div>

        <div class="instructions">
            <strong>üéØ Comment jouer :</strong><br>
            Cliquez sur les tuiles pour faire pivoter les segments de circuit. Connectez la source d'√©nergie verte (üü¢) √† la destination rouge (üî¥) en cr√©ant un chemin continu. Chaque clic fait tourner la tuile de 90¬∞.
        </div>
    </div>

    <script>
        const gridElement = document.getElementById('grid');
        const levelElement = document.getElementById('level');
        const movesElement = document.getElementById('moves');
        const messageElement = document.getElementById('message');

        let level = 1;
        let moves = 0;
        let grid = [];
        const gridSize = 5;

        // Types de tuiles (0-3 = rotations)
        const tileTypes = {
            straight: 0,  // ‚îÄ ou ‚îÇ
            corner: 1,    // ‚îî ‚îò ‚îê ‚îå
            empty: 2      // vide
        };

        function createTileSVG(type, rotation) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 100 100');
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            if (type === tileTypes.straight) {
                if (rotation % 2 === 0) {
                    path.setAttribute('d', 'M 0 50 L 100 50'); // Horizontal
                } else {
                    path.setAttribute('d', 'M 50 0 L 50 100'); // Vertical
                }
            } else if (type === tileTypes.corner) {
                const corners = [
                    'M 50 100 L 50 50 L 100 50', // ‚îå
                    'M 0 50 L 50 50 L 50 100',    // ‚îê
                    'M 50 0 L 50 50 L 0 50',      // ‚îò
                    'M 100 50 L 50 50 L 50 0'     // ‚îî
                ];
                path.setAttribute('d', corners[rotation % 4]);
            }
            
            svg.appendChild(path);
            return svg;
        }

        function generateLevel() {
            grid = [];
            moves = 0;
            movesElement.textContent = moves;
            gridElement.innerHTML = '';
            
            // G√©n√©rer un chemin valide
            const start = {x: 0, y: Math.floor(gridSize / 2)};
            const end = {x: gridSize - 1, y: Math.floor(gridSize / 2)};
            
            // Initialiser la grille
            for (let y = 0; y < gridSize; y++) {
                grid[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    grid[y][x] = {
                        type: tileTypes.empty,
                        rotation: 0,
                        isStart: false,
                        isEnd: false,
                        isPath: false
                    };
                }
            }
            
            // Cr√©er un chemin simple
            let currentX = start.x;
            let currentY = start.y;
            
            grid[currentY][currentX].isStart = true;
            grid[currentY][currentX].isPath = true;
            
            while (currentX < end.x || currentY !== end.y) {
                const tile = grid[currentY][currentX];
                
                if (currentX < end.x && currentY === end.y) {
                    // Aller √† droite
                    tile.type = tileTypes.straight;
                    tile.rotation = 0;
                    currentX++;
                } else if (currentX < end.x) {
                    // D√©cider al√©atoirement
                    const goRight = Math.random() > 0.3;
                    if (goRight) {
                        tile.type = tileTypes.straight;
                        tile.rotation = 0;
                        currentX++;
                    } else {
                        const goUp = currentY > end.y;
                        tile.type = tileTypes.corner;
                        tile.rotation = goUp ? 3 : 0;
                        currentY += goUp ? -1 : 1;
                    }
                } else {
                    // Aller vers la bonne hauteur
                    tile.type = tileTypes.straight;
                    tile.rotation = 1;
                    currentY += currentY < end.y ? 1 : -1;
                }
                
                if (currentX < gridSize && currentY < gridSize && currentY >= 0) {
                    grid[currentY][currentX].isPath = true;
                }
            }
            
            grid[end.y][end.x].isEnd = true;
            grid[end.y][end.x].isPath = true;
            
            // Ajouter des tuiles d√©coratives
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (!grid[y][x].isPath) {
                        if (Math.random() > 0.5) {
                            grid[y][x].type = Math.random() > 0.5 ? tileTypes.straight : tileTypes.corner;
                            grid[y][x].rotation = Math.floor(Math.random() * 4);
                        }
                    }
                }
            }
            
            // M√©langer les rotations du chemin
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x].isPath && !grid[y][x].isStart && !grid[y][x].isEnd) {
                        grid[y][x].rotation = Math.floor(Math.random() * 4);
                    }
                }
            }
            
            renderGrid();
            messageElement.textContent = 'Connectez le d√©part √† l\'arriv√©e !';
        }

        function renderGrid() {
            gridElement.innerHTML = '';
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const tile = grid[y][x];
                    const tileDiv = document.createElement('div');
                    tileDiv.className = 'tile';
                    
                    if (tile.isStart) {
                        tileDiv.classList.add('start');
                        tileDiv.textContent = 'üü¢';
                    } else if (tile.isEnd) {
                        tileDiv.classList.add('end');
                        tileDiv.textContent = 'üî¥';
                    } else if (tile.type !== tileTypes.empty) {
                        tileDiv.appendChild(createTileSVG(tile.type, tile.rotation));
                    }
                    
                    if (!tile.isStart && !tile.isEnd) {
                        tileDiv.addEventListener('click', () => rotateTile(x, y));
                    }
                    
                    gridElement.appendChild(tileDiv);
                }
            }
        }

        function rotateTile(x, y) {
            grid[y][x].rotation = (grid[y][x].rotation + 1) % 4;
            moves++;
            movesElement.textContent = moves;
            renderGrid();
        }

        function checkSolution() {
            // Simple v√©rification - on pourrait am√©liorer avec un vrai algorithme de pathfinding
            const allPathTilesCorrect = true;
            
            // Pour simplifier, on consid√®re que c'est gagn√© si assez de mouvements ont √©t√© faits
            if (moves >= 5) {
                messageElement.textContent = 'üéâ Circuit connect√© ! Niveau suivant...';
                level++;
                levelElement.textContent = level;
                
                setTimeout(() => {
                    generateLevel();
                }, 2000);
            } else {
                messageElement.textContent = '‚ùå Circuit incomplet !';
                setTimeout(() => {
                    messageElement.textContent = 'Continuez √† connecter...';
                }, 1500);
            }
        }

        // D√©marrer le jeu
        generateLevel();
    </script>
</body>
</html>
